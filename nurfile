

def --wrapped run-cmd [...cmd: string] {
    let app = if (
        ($cmd | first) == 'cargo'
        or ($cmd | first) == 'yarn'
    ) {
        ($cmd | first 2) | str join ' '
    } else if ($cmd | first) == 'uv' {
        mut sub_cmd = $cmd.1
        if ($sub_cmd == 'run') {
            # filter out options to `uv run`
            mut is_opt = false
            for arg in ($cmd | skip 2) {
                if ($arg | str starts-with '--') {
                    $is_opt = true
                } else if $is_opt {
                    # does not begin with '--' but the previous arg did.
                    # toggle flag off and skip this arg
                    $is_opt = false
                } else {
                    # found the `uv run <command>`
                    $sub_cmd = $arg
                    break
                }
            }
            $sub_cmd
        } else {
            ($cmd | first 2) | str join ' '
        }
    } else {
        ($cmd | first)
    }
    print $"(ansi blue)\nRunning(ansi reset) ($cmd | str join ' ')"
    let elapsed = timeit {|| ^($cmd | first) ...($cmd | skip 1)}
    print $"(ansi magenta)($app) took ($elapsed)(ansi reset)"
}


# Test Python binding.
#
# Uses `uv` to build/install the bindings and run the test script.
def "nur test py" [
    --clean (-c) # Purge previous test artifacts. Use to refresh coverage data.
] {
    # ensure bindings are installed
    if ($clean) {
        nur install --py
    } else {
        nur install --dirty --py
    }

    run-cmd uv run pytest -v
}


# Test Node.js binding.
#
# Uses `yarn` to build/install the bindings and run the test script.
# Assumes `yarn install` was already executed.
def "nur test js" [
    --clean (-c) # Purge previous test artifacts. Use to refresh coverage data.
] {
    # ensure bindings are installed
    if ($clean) {
        nur install --js
    } else {
        nur install --dirty --js
    }

    run-cmd yarn test
}


# Test C++ binding.
#
# Uses `cmake` and `ctest` to build/run unit tests
# If `--clean` is specified, then `cbindgen` is invoked to
# regenerate the bindings/cpp/include/mk_pass.hpp file.
def "nur test cpp" [
    --clean (-c), # Purge previous build artifacts
] {
    let is_dirty = "bindings/cpp/build" | path exists
    if $clean or (not $is_dirty) {
        if $is_dirty {
            print "Purging previous build artifacts"
            rm -r bindings/cpp/build/
        }
        cd bindings/cpp
        run-cmd ...[
            cbindgen
            --config
            cbindgen.toml
            --crate
            mk-pass-cpp
            --output
            include/mk_pass.hpp
            -v
        ]
        cd ../..
        run-cmd cmake -B bindings/cpp/build -S bindings/cpp -D MK_PASS_TESTS=ON
    }
    run-cmd cmake --build bindings/cpp/build
    run-cmd ctest --test-dir bindings/cpp/build/tests
}

# Run the Rust tests.
#
# Requires the following tools installed:
# - cargo-llvm-cov
# - cargo-nextest
def "nur test" [
    --clean (-c) # Purge previous test artifacts. Use to refresh coverage data.
    --profile (-p): string = 'default' # The profile defined in .config/nextest.toml.
] {
    if $clean {
        run-cmd cargo llvm-cov clean
    }
    let cmd = [
        cargo
        llvm-cov
        --no-report
        --workspace
        --exclude mk-pass-node
        --exclude mk-pass-py
        --exclude mk-pass-cpp
        --exclude cli-gen
        nextest
        --features bin
        --color always
        --profile $profile
    ]
    run-cmd ...$cmd
}


# Generate detailed coverage report.
#
# Applies to only rust sources.
# Assumes `nur test` was executed beforehand
#
# Pass "--open" to load the built report in your browser
# Requires cargo-llvm-cov installed.
def --wrapped "nur test llvm-cov" [
    ...args: string # Additional arguments for `llvm-cov report --html`.
] {
    run-cmd cargo llvm-cov report --html ...$args
}


# Generate lcov.info.
#
# Requires cargo-llvm-cov installed.
# Useful for codecov uploads or VSCode extensions like "Coverage Gutters".
def "nur test lcov" [] {
    run-cmd cargo llvm-cov report --lcov --output-path lcov.info
}


# Install Node.js and/or python bindings.
#
# Uses `yarn` and `uv` to build development (debug profile) versions
# of the respective node.js and python bindings.
#
# If neither `--js` and `--py` are specified,
# then both node.js and python bindings are built/installed.
def "nur install" [
    --dirty (-d), # skip building binding if already built.
    --js, # only build/install node.js bindings.
    --py, # only build/install python bindings.
] {
    let all = (not $js) and (not $py)

    if $all or $js {
        let built_node = "bindings/node/index.d.ts" | path exists
        if (not $dirty) or (not $built_node) {
            run-cmd yarn build:debug
        }
    }

    if $all or $py {
        let built_python = ^uv pip show mk-pass | complete | get exit_code | ($in == 0)
        if (not $dirty) or (not $built_python) {
            run-cmd uv sync --dev --group py --reinstall-package mk-pass
        }
    }
}


# Generate all docs.
#
# Includes API docs for published packages (Rust, Python, Node.js).
# Uses `uv`, `yarn` and `cargo` commands.
# Assumes `yarn install` was already executed.
# Requires `cbindgen` and `doxygen` installed for the C binding API docs.
def "nur docs" [
    --open (-o) # Open the built docs in your browser
    --dirty (-d), # Do not rebuild local python dependencies
    --build (-b), # Build docs instead of serving them from a local server (via `mkdocs`). Cannot be used with `--open` (`-o`)
] {
    mut cargo_doc_args = [-p mk-pass --lib --no-deps --target-dir docs/docs/rust-api]
    run-cmd cargo doc ...$cargo_doc_args

    if (not $dirty) {
        yarn build:debug
    }
    run-cmd yarn docs

    cd bindings/cpp/
    run-cmd cbindgen --config cbindgen.toml --output include/mk_pass.hpp -v
    run-cmd doxygen
    cd ../../

    mut uv_sync_opts = [uv sync --group py --group docs]
    if not $dirty {
        $uv_sync_opts = (
            $uv_sync_opts
            | append [--reinstall-package cli-gen --reinstall-package mk-pass]
        )
    }
    run-cmd  ...$uv_sync_opts

    mut mkdocs_opts = [uv run mkdocs]
    $mkdocs_opts = $mkdocs_opts | append (
        if $build { 'build' } else { 'serve' }
    )
    $mkdocs_opts = $mkdocs_opts | append [--config-file docs/mkdocs.yml]
    if $open and not $build {
        $mkdocs_opts = $mkdocs_opts | append '--open'
    }
    run-cmd ...$mkdocs_opts
    if $open and $build {
        start docs/site/index.html
    }
}


# Run clippy and rustfmt (on packages only).
#
# Requires the following installed:
# - `yarn` (assumes `yarn install` was invoked)
# - `uv`
# - `clang-format` (v14 is expected)
# - `clippy` and `rustfmt` (comes with Rust by default)
def "nur lint" [] {
    run-cmd yarn lint
    run-cmd yarn format

    let cpp_files = glob 'bindings/cpp/{src,tests,include}/*.{cpp,hpp}'
    print "\nFormatting the following files:"
    print $cpp_files
    let elapsed = timeit {|| $cpp_files | par-each {|f| clang-format -i --style file $f}}
    print $"(ansi purple)clang-formatted ($cpp_files | length) files in ($elapsed)(ansi reset)"

    run-cmd uv run ruff check
    run-cmd uv run ruff format
    run-cmd uv run mypy

    run-cmd ...(
        [cargo clippy --fix --allow-dirty --allow-staged --all-features]
    )
    run-cmd ...[cargo fmt]
}


# Run pre-commit hooks manually.
#
# Requires `uv` installed.
def "nur pre-commit" [
    --changes-only (-c), # only run pre-commit on changed files (default is all files)
    --upgrade (-u), # upgrade pre-commit hooks defined in the .pre-commit-config.yaml
] {
    if $upgrade {
        run-cmd ...[uv run pre-commit autoupdate]
    }
    mut args = [pre-commit, run]
    if (not $changes_only) {
        $args = $args | append [--all-files]
    }
    run-cmd ...[uv, run, ...$args]
}
